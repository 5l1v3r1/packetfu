Rough notes on implementing new protocols

Implementing new protocols. An example is IPv6:

Step one, create a BinData struct to describe the protocol. They're called Headers, but they're really headers and payloads.
	All fields should start with a protocol-identifying label:
		ipv6_v, ipv6_class, etc.
	
	All externally-accessable functions should also start with the same label:
		ipv6_calc_len
	
	Create any sub-structs. Note that CamelCase class names turn into camel_case data types, so IPv6 would become i_pv6, probably not what you want.
		AddrIpv6
	
	The payload data type (where higher-level data go) must be called "body". It's usually :rest, but can also be a :string or whatever.
				
	If you have calculated fields, you will probably want a recalc function. This way if the user sets a calculated
field to an absoulte value, they can easily reset it to a calculated value later.
		ipv6_recalc

	If you have data that has a normal presentation for humans, create those functions.
		ipv6_saddr, ipv6_daddr, ipv6_saddr=, ipv6_daddr

Step two, create a Packet container, subclassed from Packet. They have a pretty standard format which define parent headers.
	IPv6Packet

	Add a peek() method to the Packet to collect summary data of the packet. Useful for troubleshooting and Capture.show_live
	
	If there are particlar flavors of packets you'd like to predefine, add them to the initialize as an args[:flavor].

Step three, create a method_missing handler switch for your new packet type. This allows users to manipulate header types
from outside the packet.
	Packet::method_missing, when /^ipv6_/

Step four, add the packet type to the parse() and read() trees in Packet.
	This can get byzantine.

Step five, fire up show_live and see if it all works!


	
